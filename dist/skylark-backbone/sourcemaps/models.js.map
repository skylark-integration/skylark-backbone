{"version":3,"sources":["models.js"],"names":["define","langx","methodMap","create","update","patch","delete","read","wrapError","model","options","error","resp","call","context","trigger","Entity","Stateful","inherit","sync","models","apply","this","arguments","matches","attrs","isMatch","attributes","fetch","entity","success","mixin","parse","serverAttrs","set","save","key","val","wait","validate","_validate","method","isNew","xhr","destroy","clone","stopListening","collection","defer","url","base","result","urlError","id","get","idAttribute","replace","encodeURIComponent","Collection","Evented","_construct","entities","comparator","_reset","reset","silent","setOptions","add","remove","merge","addOptions","splice","array","insert","at","Math","min","max","length","i","tail","Array","partial","initialize","toJSON","map","singular","isArray","slice","removed","_removeEntitys","changes","added","merged","_isEntity","toAdd","toMerge","toRemove","modelMap","sort","sortable","sortAttr","isString","existing","push","hasChanged","cid","_prepareEntity","_addReference","orderChanged","some","m","index","_removeReference","previousEntitys","pop","unshift","shift","obj","_byId","entityId","has","where","first","findWhere","Error","isFunction","proxy","sortBy","pluck","attr","callbackOpts","constructor","prototype","validationError","indexOf","on","_onEntityEvent","off","event","prevId","previousAttributes","emulateHTTP","emulateJSON","type","defaults","params","dataType","data","contentType","JSON","stringify","_method","beforeSend","setRequestHeader","processData","textStatus","errorThrown","Xhr","request"],"mappings":"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","file":"../models.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\"\r\n], function(langx) {\r\n\r\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\r\n  var methodMap = {\r\n    'create': 'POST',\r\n    'update': 'PUT',\r\n    'patch': 'PATCH',\r\n    'delete': 'DELETE',\r\n    'read': 'GET'\r\n  };\r\n  \r\n  // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function(model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error.call(options.context, model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n  var sync = function(method, entity, options) {\r\n    var type = methodMap[method];\r\n\r\n    // Default options, unless specified.\r\n    langx.defaults(options || (options = {}), {\r\n      emulateHTTP: models.emulateHTTP,\r\n      emulateJSON: models.emulateJSON\r\n    });\r\n\r\n    // Default JSON-request options.\r\n    var params = {type: type, dataType: 'json'};\r\n\r\n    // Ensure that we have a URL.\r\n    if (!options.url) {\r\n      params.url = langx.result(entity, 'url') || urlError();\r\n    }\r\n\r\n    // Ensure that we have the appropriate request data.\r\n    if (options.data == null && entity && (method === 'create' || method === 'update' || method === 'patch')) {\r\n      params.contentType = 'application/json';\r\n      params.data = JSON.stringify(options.attrs || entity.toJSON(options));\r\n    }\r\n\r\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\r\n    if (options.emulateJSON) {\r\n      params.contentType = 'application/x-www-form-urlencoded';\r\n      params.data = params.data ? {entity: params.data} : {};\r\n    }\r\n\r\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\r\n    // And an `X-HTTP-Method-Override` header.\r\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\r\n      params.type = 'POST';\r\n      if (options.emulateJSON) params.data._method = type;\r\n      var beforeSend = options.beforeSend;\r\n      options.beforeSend = function(xhr) {\r\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\r\n        if (beforeSend) return beforeSend.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    // Don't process data on a non-GET request.\r\n    if (params.type !== 'GET' && !options.emulateJSON) {\r\n      params.processData = false;\r\n    }\r\n\r\n    // Pass along `textStatus` and `errorThrown` from jQuery.\r\n    var error = options.error;\r\n    options.error = function(xhr, textStatus, errorThrown) {\r\n      options.textStatus = textStatus;\r\n      options.errorThrown = errorThrown;\r\n      if (error) error.call(options.context, xhr, textStatus, errorThrown);\r\n    };\r\n\r\n    // Make the request, allowing the user to override any Ajax options.\r\n    var xhr = options.xhr = langx.Xhr.request(langx.mixin(params, options));\r\n    entity.trigger('request', entity, xhr, options);\r\n    return xhr;\r\n  };\r\n\r\n\r\n  var Entity = langx.Stateful.inherit({\r\n    sync: function() {\r\n      return models.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Get the HTML-escaped value of an attribute.\r\n    //escape: function(attr) {\r\n    //  return _.escape(this.get(attr));\r\n    //},\r\n\r\n    // Special-cased proxy to underscore's `_.matches` method.\r\n    matches: function(attrs) {\r\n      return langx.isMatch(this.attributes,attrs);\r\n    },\r\n\r\n    // Fetch the entity from the server, merging the response with the entity's\r\n    // local attributes. Any changed attributes will trigger a \"change\" event.\r\n    fetch: function(options) {\r\n      options = langx.mixin({parse: true}, options);\r\n      var entity = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;\r\n        if (!entity.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        entity.trigger('sync', entity, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Set a hash of entity attributes, and sync the entity to the server.\r\n    // If the server returns an attributes hash that differs, the entity's\r\n    // state will be `set` again.\r\n    save: function(key, val, options) {\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      var attrs;\r\n      if (key == null || typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      options = langx.mixin({validate: true, parse: true}, options);\r\n      var wait = options.wait;\r\n\r\n      // If we're not waiting and attributes exist, save acts as\r\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\r\n      // the entity will be valid when the attributes, if any, are set.\r\n      if (attrs && !wait) {\r\n        if (!this.set(attrs, options)) return false;\r\n      } else if (!this._validate(attrs, options)) {\r\n        return false;\r\n      }\r\n\r\n      // After a successful server-side save, the client is (optionally)\r\n      // updated with the server-side state.\r\n      var entity = this;\r\n      var success = options.success;\r\n      var attributes = this.attributes;\r\n      options.success = function(resp) {\r\n        // Ensure attributes are restored during synchronous saves.\r\n        entity.attributes = attributes;\r\n        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;\r\n        if (wait) serverAttrs = langx.mixin({}, attrs, serverAttrs);\r\n        if (serverAttrs && !entity.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        entity.trigger('sync', entity, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n\r\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\r\n      if (attrs && wait) this.attributes = langx.mixin({}, attributes, attrs);\r\n\r\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\r\n      var xhr = this.sync(method, this, options);\r\n\r\n      // Restore attributes.\r\n      this.attributes = attributes;\r\n\r\n      return xhr;\r\n    },\r\n\r\n    // Destroy this entity on the server if it was already persisted.\r\n    // Optimistically removes the entity from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy: function(options) {\r\n      options = options ? langx.clone(options) : {};\r\n      var entity = this;\r\n      var success = options.success;\r\n      var wait = options.wait;\r\n\r\n      var destroy = function() {\r\n        entity.stopListening();\r\n        entity.trigger('destroy', entity, entity.collection, options);\r\n      };\r\n\r\n      options.success = function(resp) {\r\n        if (wait) destroy();\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        if (!entity.isNew()) entity.trigger('sync', entity, resp, options);\r\n      };\r\n\r\n      var xhr = false;\r\n      if (this.isNew()) {\r\n        langx.defer(options.success);\r\n      } else {\r\n        wrapError(this, options);\r\n        xhr = this.sync('delete', this, options);\r\n      }\r\n      if (!wait) destroy();\r\n      return xhr;\r\n    },\r\n\r\n    // Default URL for the entity's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url: function() {\r\n      var base =\r\n        langx.result(this, 'urlRoot') ||\r\n        langx.result(this.collection, 'url') ||\r\n        urlError();\r\n      if (this.isNew()) return base;\r\n      var id = this.get(this.idAttribute);\r\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\r\n    },\r\n\r\n    // **parse** converts a response into the hash of attributes to be `set` on\r\n    // the entity. The default implementation is just to pass the response along.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    }\r\n  });\r\n\r\n  var Collection  = langx.Evented.inherit({\r\n    \"_construct\" : function(entities, options) {\r\n      options || (options = {});\r\n      if (options.entity) this.entity = options.entity;\r\n      if (options.comparator !== void 0) this.comparator = options.comparator;\r\n      this._reset();\r\n      if (entities) this.reset(entities, langx.mixin({silent: true}, options));\r\n    }\r\n  }); \r\n\r\n  // Default options for `Collection#set`.\r\n  var setOptions = {add: true, remove: true, merge: true};\r\n  var addOptions = {add: true, remove: false};\r\n\r\n  // Splices `insert` into `array` at index `at`.\r\n  var splice = function(array, insert, at) {\r\n    at = Math.min(Math.max(at, 0), array.length);\r\n    var tail = Array(array.length - at);\r\n    var length = insert.length;\r\n    var i;\r\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\r\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\r\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\r\n  };\r\n\r\n  // Define the Collection's inheritable methods.\r\n  Collection.partial({\r\n\r\n    // The default entity for a collection is just a **Entity**.\r\n    // This should be overridden in most cases.\r\n    entity: Entity,\r\n\r\n    // Initialize is an empty function by default. Override it with your own\r\n    // initialization logic.\r\n    initialize: function(){},\r\n\r\n    // The JSON representation of a Collection is an array of the\r\n    // entities' attributes.\r\n    toJSON: function(options) {\r\n      return this.map(function(entity) { return entity.toJSON(options); });\r\n    },\r\n\r\n    // Proxy `models.sync` by default.\r\n    sync: function() {\r\n      return models.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Add a entity, or list of entities to the set. `entities` may be Backbone\r\n    // Entitys or raw JavaScript objects to be converted to Entitys, or any\r\n    // combination of the two.\r\n    add: function(entities, options) {\r\n      return this.set(entities, langx.mixin({merge: false}, options, addOptions));\r\n    },\r\n\r\n    // Remove a entity, or a list of entities from the set.\r\n    remove: function(entities, options) {\r\n      options = langx.mixin({}, options);\r\n      var singular = !langx.isArray(entities);\r\n      entities = singular ? [entities] : entities.slice();\r\n      var removed = this._removeEntitys(entities, options);\r\n      if (!options.silent && removed.length) {\r\n        options.changes = {added: [], merged: [], removed: removed};\r\n        this.trigger('update', this, options);\r\n      }\r\n      return singular ? removed[0] : removed;\r\n    },\r\n\r\n    // Update a collection by `set`-ing a new list of entities, adding new ones,\r\n    // removing entities that are no longer present, and merging entities that\r\n    // already exist in the collection, as necessary. Similar to **Entity#set**,\r\n    // the core operation for updating the data contained by the collection.\r\n    set: function(entities, options) {\r\n      if (entities == null) return;\r\n\r\n      options = langx.mixin({}, setOptions, options);\r\n      if (options.parse && !this._isEntity(entities)) {\r\n        entities = this.parse(entities, options) || [];\r\n      }\r\n\r\n      var singular = !langx.isArray(entities);\r\n      entities = singular ? [entities] : entities.slice();\r\n\r\n      var at = options.at;\r\n      if (at != null) at = +at;\r\n      if (at > this.length) at = this.length;\r\n      if (at < 0) at += this.length + 1;\r\n\r\n      var set = [];\r\n      var toAdd = [];\r\n      var toMerge = [];\r\n      var toRemove = [];\r\n      var modelMap = {};\r\n\r\n      var add = options.add;\r\n      var merge = options.merge;\r\n      var remove = options.remove;\r\n\r\n      var sort = false;\r\n      var sortable = this.comparator && at == null && options.sort !== false;\r\n      var sortAttr = langx.isString(this.comparator) ? this.comparator : null;\r\n\r\n      // Turn bare objects into entity references, and prevent invalid entities\r\n      // from being added.\r\n      var entity, i;\r\n      for (i = 0; i < entities.length; i++) {\r\n        entity = entities[i];\r\n\r\n        // If a duplicate is found, prevent it from being added and\r\n        // optionally merge it into the existing entity.\r\n        var existing = this.get(entity);\r\n        if (existing) {\r\n          if (merge && entity !== existing) {\r\n            var attrs = this._isEntity(entity) ? entity.attributes : entity;\r\n            if (options.parse) attrs = existing.parse(attrs, options);\r\n            existing.set(attrs, options);\r\n            toMerge.push(existing);\r\n            if (sortable && !sort) sort = existing.hasChanged(sortAttr);\r\n          }\r\n          if (!modelMap[existing.cid]) {\r\n            modelMap[existing.cid] = true;\r\n            set.push(existing);\r\n          }\r\n          entities[i] = existing;\r\n\r\n        // If this is a new, valid entity, push it to the `toAdd` list.\r\n        } else if (add) {\r\n          entity = entities[i] = this._prepareEntity(entity, options);\r\n          if (entity) {\r\n            toAdd.push(entity);\r\n            this._addReference(entity, options);\r\n            modelMap[entity.cid] = true;\r\n            set.push(entity);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove stale entities.\r\n      if (remove) {\r\n        for (i = 0; i < this.length; i++) {\r\n          entity = this.entities[i];\r\n          if (!modelMap[entity.cid]) toRemove.push(entity);\r\n        }\r\n        if (toRemove.length) this._removeEntitys(toRemove, options);\r\n      }\r\n\r\n      // See if sorting is needed, update `length` and splice in new entities.\r\n      var orderChanged = false;\r\n      var replace = !sortable && add && remove;\r\n      if (set.length && replace) {\r\n        orderChanged = this.length !== set.length || this.entities.some(function(m, index) {\r\n          return m !== set[index];\r\n        });\r\n        this.entities.length = 0;\r\n        splice(this.entities, set, 0);\r\n        this.length = this.entities.length;\r\n      } else if (toAdd.length) {\r\n        if (sortable) sort = true;\r\n        splice(this.entities, toAdd, at == null ? this.length : at);\r\n        this.length = this.entities.length;\r\n      }\r\n\r\n      // Silently sort the collection if appropriate.\r\n      if (sort) this.sort({silent: true});\r\n\r\n      // Unless silenced, it's time to fire all appropriate add/sort/update events.\r\n      if (!options.silent) {\r\n        for (i = 0; i < toAdd.length; i++) {\r\n          if (at != null) options.index = at + i;\r\n          entity = toAdd[i];\r\n          entity.trigger('add', entity, this, options);\r\n        }\r\n        if (sort || orderChanged) this.trigger('sort', this, options);\r\n        if (toAdd.length || toRemove.length || toMerge.length) {\r\n          options.changes = {\r\n            added: toAdd,\r\n            removed: toRemove,\r\n            merged: toMerge\r\n          };\r\n          this.trigger('update', this, options);\r\n        }\r\n      }\r\n\r\n      // Return the added (or merged) entity (or entities).\r\n      return singular ? entities[0] : entities;\r\n    },\r\n\r\n    // When you have more items than you want to add or remove individually,\r\n    // you can reset the entire set with a new list of entities, without firing\r\n    // any granular `add` or `remove` events. Fires `reset` when finished.\r\n    // Useful for bulk operations and optimizations.\r\n    reset: function(entities, options) {\r\n      options = options ? langx.clone(options) : {};\r\n      for (var i = 0; i < this.entities.length; i++) {\r\n        this._removeReference(this.entities[i], options);\r\n      }\r\n      options.previousEntitys = this.entities;\r\n      this._reset();\r\n      entities = this.add(entities, langx.mixin({silent: true}, options));\r\n      if (!options.silent) this.trigger('reset', this, options);\r\n      return entities;\r\n    },\r\n\r\n    // Add a entity to the end of the collection.\r\n    push: function(entity, options) {\r\n      return this.add(entity, langx.mixin({at: this.length}, options));\r\n    },\r\n\r\n    // Remove a entity from the end of the collection.\r\n    pop: function(options) {\r\n      var entity = this.at(this.length - 1);\r\n      return this.remove(entity, options);\r\n    },\r\n\r\n    // Add a entity to the beginning of the collection.\r\n    unshift: function(entity, options) {\r\n      return this.add(entity, langx.mixin({at: 0}, options));\r\n    },\r\n\r\n    // Remove a entity from the beginning of the collection.\r\n    shift: function(options) {\r\n      var entity = this.at(0);\r\n      return this.remove(entity, options);\r\n    },\r\n\r\n    // Slice out a sub-array of entities from the collection.\r\n    slice: function() {\r\n      return slice.apply(this.entities, arguments);\r\n    },\r\n\r\n    // Get a entity from the set by id, cid, entity object with id or cid\r\n    // properties, or an attributes object that is transformed through entityId.\r\n    get: function(obj) {\r\n      if (obj == null) return void 0;\r\n      return this._byId[obj] ||\r\n        this._byId[this.entityId(obj.attributes || obj)] ||\r\n        obj.cid && this._byId[obj.cid];\r\n    },\r\n\r\n    // Returns `true` if the entity is in the collection.\r\n    has: function(obj) {\r\n      return this.get(obj) != null;\r\n    },\r\n\r\n    // Get the entity at the given index.\r\n    at: function(index) {\r\n      if (index < 0) index += this.length;\r\n      return this.entities[index];\r\n    },\r\n\r\n    // Return entities with matching attributes. Useful for simple cases of\r\n    // `filter`.\r\n    where: function(attrs, first) {\r\n      return this[first ? 'find' : 'filter'](attrs);\r\n    },\r\n\r\n    // Return the first entity with matching attributes. Useful for simple cases\r\n    // of `find`.\r\n    findWhere: function(attrs) {\r\n      return this.where(attrs, true);\r\n    },\r\n\r\n    // Force the collection to re-sort itself. You don't need to call this under\r\n    // normal circumstances, as the set will maintain sort order as each item\r\n    // is added.\r\n    sort: function(options) {\r\n      var comparator = this.comparator;\r\n      if (!comparator) throw new Error('Cannot sort a set without a comparator');\r\n      options || (options = {});\r\n\r\n      var length = comparator.length;\r\n      if (langx.isFunction(comparator)) comparator = langx.proxy(comparator, this);\r\n\r\n      // Run sort based on type of `comparator`.\r\n      if (length === 1 || langx.isString(comparator)) {\r\n        this.entities = this.sortBy(comparator);\r\n      } else {\r\n        this.entities.sort(comparator);\r\n      }\r\n      if (!options.silent) this.trigger('sort', this, options);\r\n      return this;\r\n    },\r\n\r\n    // Pluck an attribute from each entity in the collection.\r\n    pluck: function(attr) {\r\n      return this.map(attr + '');\r\n    },\r\n\r\n    // Fetch the default set of entities for this collection, resetting the\r\n    // collection when they arrive. If `reset: true` is passed, the response\r\n    // data will be passed through the `reset` method instead of `set`.\r\n    fetch: function(options) {\r\n      options = langx.mixin({parse: true}, options);\r\n      var success = options.success;\r\n      var collection = this;\r\n      options.success = function(resp) {\r\n        var method = options.reset ? 'reset' : 'set';\r\n        collection[method](resp, options);\r\n        if (success) success.call(options.context, collection, resp, options);\r\n        collection.trigger('sync', collection, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Create a new instance of a entity in this collection. Add the entity to the\r\n    // collection immediately, unless `wait: true` is passed, in which case we\r\n    // wait for the server to agree.\r\n    create: function(entity, options) {\r\n      options = options ? langx.clone(options) : {};\r\n      var wait = options.wait;\r\n      entity = this._prepareEntity(entity, options);\r\n      if (!entity) return false;\r\n      if (!wait) this.add(entity, options);\r\n      var collection = this;\r\n      var success = options.success;\r\n      options.success = function(m, resp, callbackOpts) {\r\n        if (wait) collection.add(m, callbackOpts);\r\n        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\r\n      };\r\n      entity.save(null, options);\r\n      return entity;\r\n    },\r\n\r\n    // **parse** converts a response into a list of entities to be added to the\r\n    // collection. The default implementation is just to pass it through.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    },\r\n\r\n    // Create a new collection with an identical list of entities as this one.\r\n    clone: function() {\r\n      return new this.constructor(this.entities, {\r\n        entity: this.entity,\r\n        comparator: this.comparator\r\n      });\r\n    },\r\n\r\n    // Define how to uniquely identify entities in the collection.\r\n    entityId: function(attrs) {\r\n      return attrs[this.entity.prototype.idAttribute || 'id'];\r\n    },\r\n\r\n    // Private method to reset all internal state. Called when the collection\r\n    // is first initialized or reset.\r\n    _reset: function() {\r\n      this.length = 0;\r\n      this.entities = [];\r\n      this._byId  = {};\r\n    },\r\n\r\n    // Prepare a hash of attributes (or other entity) to be added to this\r\n    // collection.\r\n    _prepareEntity: function(attrs, options) {\r\n      if (this._isEntity(attrs)) {\r\n        if (!attrs.collection) attrs.collection = this;\r\n        return attrs;\r\n      }\r\n      options = options ? langx.clone(options) : {};\r\n      options.collection = this;\r\n      var entity = new this.entity(attrs, options);\r\n      if (!entity.validationError) return entity;\r\n      this.trigger('invalid', this, entity.validationError, options);\r\n      return false;\r\n    },\r\n\r\n    // Internal method called by both remove and set.\r\n    _removeEntitys: function(entities, options) {\r\n      var removed = [];\r\n      for (var i = 0; i < entities.length; i++) {\r\n        var entity = this.get(entities[i]);\r\n        if (!entity) continue;\r\n\r\n        var index = this.indexOf(entity);\r\n        this.entities.splice(index, 1);\r\n        this.length--;\r\n\r\n        // Remove references before triggering 'remove' event to prevent an\r\n        // infinite loop. #3693\r\n        delete this._byId[entity.cid];\r\n        var id = this.entityId(entity.attributes);\r\n        if (id != null) delete this._byId[id];\r\n\r\n        if (!options.silent) {\r\n          options.index = index;\r\n          entity.trigger('remove', entity, this, options);\r\n        }\r\n\r\n        removed.push(entity);\r\n        this._removeReference(entity, options);\r\n      }\r\n      return removed;\r\n    },\r\n\r\n    // Method for checking whether an object should be considered a entity for\r\n    // the purposes of adding to the collection.\r\n    _isEntity: function(entity) {\r\n      return entity instanceof Entity;\r\n    },\r\n\r\n    // Internal method to create a entity's ties to a collection.\r\n    _addReference: function(entity, options) {\r\n      this._byId[entity.cid] = entity;\r\n      var id = this.entityId(entity.attributes);\r\n      if (id != null) this._byId[id] = entity;\r\n      entity.on('all', this._onEntityEvent, this);\r\n    },\r\n\r\n    // Internal method to sever a entity's ties to a collection.\r\n    _removeReference: function(entity, options) {\r\n      delete this._byId[entity.cid];\r\n      var id = this.entityId(entity.attributes);\r\n      if (id != null) delete this._byId[id];\r\n      if (this === entity.collection) delete entity.collection;\r\n      entity.off('all', this._onEntityEvent, this);\r\n    },\r\n\r\n    // Internal method called every time a entity in the set fires an event.\r\n    // Sets need to update their indexes when entities change ids. All other\r\n    // events simply proxy through. \"add\" and \"remove\" events that originate\r\n    // in other collections are ignored.\r\n    _onEntityEvent: function(event, entity, collection, options) {\r\n      if (entity) {\r\n        if ((event === 'add' || event === 'remove') && collection !== this) return;\r\n        if (event === 'destroy') this.remove(entity, options);\r\n        if (event === 'change') {\r\n          var prevId = this.entityId(entity.previousAttributes());\r\n          var id = this.entityId(entity.attributes);\r\n          if (prevId !== id) {\r\n            if (prevId != null) delete this._byId[prevId];\r\n            if (id != null) this._byId[id] = entity;\r\n          }\r\n        }\r\n      }\r\n      this.trigger.apply(this, arguments);\r\n    }\r\n\r\n  });\r\n\r\n    function models() {\r\n        return models;\r\n    }\r\n\r\n    langx.mixin(models, {\r\n        // set a `X-Http-Method-Override` header.\r\n        emulateHTTP : false,\r\n\r\n        // Turn on `emulateJSON` to support legacy servers that can't deal with direct\r\n        // `application/json` requests ... this will encode the body as\r\n        // `application/x-www-form-urlencoded` instead and will send the model in a\r\n        // form param named `model`.\r\n        emulateJSON : false,\r\n\r\n        sync : sync,\r\n\r\n        Entity: Entity,\r\n        Collection : Collection\r\n    });\r\n\r\n\r\n    return models;\r\n});\r\n"]}