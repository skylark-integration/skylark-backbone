{"version":3,"sources":["UndoManager.js"],"names":["define","langx","_","Backbone","Model","Collection","core_slice","Array","prototype","slice","apply","fn","ctx","args","length","call","arr","index","hasKeys","obj","keys","isArray","arguments","all","key","getMagicFusionIndex","callstackWasIndexed","magicFusionIndex","defer","ObjectRegistry","this","registeredObjects","cidIndexes","onoff","which","objects","i","l","objectRegistry","register","unregister","isFunction","actionUndoRedo","action","type","undoTypes","object","before","after","options","managerUndoRedo","manager","stack","magic","everything","isCurrentlyUndoRedoing","pointer","actions","isUndo","clone","models","at","where","get","pop","shift","trigger","addToStack","track","undoTypesType","condition","validateUndoActionCreation","res","diff","add","maximumStackLength","isRegistered","cid","contains","push","splice","indexOf","map","concat","UndoTypes","undo","collection","ignore","model","remove","redo","on","undefined","change","isEmpty","each","unset","set","unsetData","afterAttributes","changedAttributes","keysAfter","previousAttributes","pick","keysPrevious","val","reset","previousModels","OwnedUndoTypes","manipulateUndoType","manipType","undoType","fns","undoTypesInstance","isObject","extend","Action","defaults","attributes","UndoStack","Infinity","setMaxLength","UndoManager","initialize","attr","value","startTracking","isArguments","stopTracking","isTracking","_addToStack","unregisterAll","undoAll","redoAll","isAvailable","s","merge","undoManager","addUndoType","changeUndoType","removeUndoType","clear","defaultAttributes"],"mappings":"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","file":"../UndoManager.js","sourcesContent":["define([\r\n  \"skylark-langx/langx\",\r\n  \"skylark-underscore/underscore\",\r\n  \"./backbone\",\r\n  \"./Model\",\r\n  \"./Collection\"\r\n\r\n],function(langx,_,Backbone,Model,Collection){\r\n\r\n\tvar core_slice = Array.prototype.slice;\r\n\r\n\t/**\r\n\t * As call is faster than apply, this is a faster version of apply as it uses call.\r\n\t * \r\n\t * @param  {Function} fn \tThe function to execute \r\n\t * @param  {Object}   ctx \tThe context the function should be called in\r\n\t * @param  {Array}    args \tThe array of arguments that should be applied to the function\r\n\t * @return Forwards whatever the called function returns\r\n\t */\r\n\tfunction apply (fn, ctx, args) {\r\n\t\treturn args.length <= 4 ?\r\n\t\t\tfn.call(ctx, args[0], args[1], args[2], args[3]) :\r\n\t\t\tfn.apply(ctx, args);\r\n\t}\r\n\r\n\t/**\r\n\t * Uses slice on an array or an array-like object.\r\n\t * \r\n\t * @param  {Array|Object} \tarr \tThe array or array-like object.\r\n\t * @param  {Number} \t\t[index]\tThe index from where the array should be sliced. Default is 0.\r\n\t * @return {Array} The sliced array\r\n\t */\r\n\tfunction slice (arr, index) {\r\n\t\treturn core_slice.call(arr, index);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if an object has one or more specific keys. The keys \r\n\t * don't have to be an owned property.\r\n\t * You can call this function either this way:\r\n\t * hasKeys(obj, [\"a\", \"b\", \"c\"])\r\n\t * or this way:\r\n\t * hasKeys(obj, \"a\", \"b\", \"c\")\r\n\t * \r\n\t * @param  {Object}  \tobj \tThe object to check on\r\n\t * @param  {Array}  \tkeys \tThe keys to check for\r\n\t * @return {Boolean} True, if the object has all those keys\r\n\t */\r\n\tfunction hasKeys (obj, keys) {\r\n\t\tif (obj == null) return false;\r\n\t\tif (!_.isArray(keys)) {\r\n\t\t\tkeys = slice(arguments, 1);\r\n\t\t}\r\n\t\treturn _.all(keys, function (key) {\r\n\t\t\treturn key in obj;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a number that is unique per call stack. The number gets \r\n\t * changed after the call stack has been completely processed.\r\n\t * \r\n\t * @return {number} MagicFusionIndex\r\n\t */\r\n\tvar getMagicFusionIndex = (function () {\r\n\t\t// If you add several models to a collection or set several\r\n\t\t// attributes on a model all in sequence and yet all for\r\n\t\t// example in one function, then several Undo-Actions are\r\n\t\t// generated.\r\n\t\t// If you want to undo your last action only the last model\r\n\t\t// would be removed from the collection or the last set\r\n\t\t// attribute would be changed back to its previous value.\r\n\t\t// To prevent that we have to figure out a way to combine\r\n\t\t// all those actions that happened \"at the same time\". \r\n\t\t// Timestamps aren't exact enough. A complex routine could \r\n\t\t// run several milliseconds and in that time produce a lot \r\n\t\t// of actions with different timestamps.\r\n\t\t// Instead we take advantage of the single-threadedness of\r\n\t\t// JavaScript:\r\n\r\n\t\tvar callstackWasIndexed = false, magicFusionIndex = -1;\r\n\t\tfunction indexCycle() {\r\n\t\t\tmagicFusionIndex++;\r\n\t\t\tcallstackWasIndexed = true;\r\n\t\t\t_.defer(function () {\r\n\t\t\t\t// Here comes the magic. With a Timeout of 0 \r\n\t\t\t\t// milliseconds this function gets called whenever\r\n\t\t\t\t// the current callstack is completed\r\n\t\t\t\tcallstackWasIndexed = false;\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn function () {\r\n\t\t\tif (!callstackWasIndexed) {\r\n\t\t\t\tindexCycle();\r\n\t\t\t}\r\n\t\t\treturn magicFusionIndex;\r\n\t\t}\r\n\t})();\r\n\r\n\t/**\r\n\t * To prevent binding a listener several times to one \r\n\t * object, we register the objects in an ObjectRegistry\r\n\t *\r\n\t * @constructor\r\n\t */\r\n\tfunction ObjectRegistry () {\r\n\t\t// This uses two different ways of storing\r\n\t\t// objects: In case the object has a cid\r\n\t\t// (which Backbone objects typically have)\r\n\t\t// it uses this cid as an index. That way\r\n\t\t// the Array's length attribute doesn't \r\n\t\t// change and the object isn't an item \r\n\t\t// in the array, but an object-property.\r\n\t\t// Otherwise it's added to the Array as an\r\n\t\t// item.\r\n\t\t// That way we can use the fast property-\r\n\t\t// lookup and only have to fall back to \r\n\t\t// iterating over the array in case \r\n\t\t// non-Backbone-objects are registered.\r\n\t\tthis.registeredObjects = [];\r\n\t\t// To return a list of all registered \r\n\t\t// objects in the 'get' method we have to\r\n\t\t// store the objects that have a cid in\r\n\t\t// an additional array. \r\n\t\tthis.cidIndexes = [];\r\n\t}\r\n\tObjectRegistry.prototype = {\r\n\t\t/**\r\n\t\t * Returns whether the object is already registered in this ObjectRegistry or not.\r\n\t\t * \r\n\t\t * @this \t{ObjectRegistry}\r\n\t\t * @param  \t{Object} \t\t obj \tThe object to check\r\n\t\t * @return \t{Boolean} True if the object is already registered\r\n\t\t */\r\n\t\tisRegistered: function (obj) {\r\n\t\t\t// This is where we get a performance boost \r\n\t\t\t// by using the two different ways of storing \r\n\t\t\t// objects.\r\n\t\t\treturn obj && obj.cid ? this.registeredObjects[obj.cid] : _.contains(this.registeredObjects, obj);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Registers an object in this ObjectRegistry.\r\n\t\t * \r\n\t\t * @this \t{ObjectRegistry}\r\n\t\t * @param  \t{Object} \t\t obj \tThe object to register\r\n\t\t * @return \t{undefined}\r\n\t\t */\r\n\t\tregister: function (obj) {\r\n\t\t\tif (!this.isRegistered(obj)) {\r\n\t\t\t\tif (obj && obj.cid) {\r\n\t\t\t\t\tthis.registeredObjects[obj.cid] = obj;\r\n\t\t\t\t\tthis.cidIndexes.push(obj.cid);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.registeredObjects.push(obj);\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Unregisters an object from this ObjectRegistry.\r\n\t\t * \r\n\t\t * @this {ObjectRegistry}\r\n\t\t * @param  {Object} obj The object to unregister\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tunregister: function (obj) {\r\n\t\t\tif (this.isRegistered(obj)) {\r\n\t\t\t\tif (obj && obj.cid) {\r\n\t\t\t\t\tdelete this.registeredObjects[obj.cid];\r\n\t\t\t\t\tthis.cidIndexes.splice(_.indexOf(this.cidIndexes, obj.cid), 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar i = _.indexOf(this.registeredObjects, obj);\r\n\t\t\t\t\tthis.registeredObjects.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Returns an array of all objects that are currently in this ObjectRegistry.\r\n\t\t * \r\n\t\t * @return {Array} An array of all the objects which are currently in the ObjectRegistry\r\n\t\t */\r\n\t\tget: function () {\r\n\t\t\treturn (_.map(this.cidIndexes, function (cid) {return this.registeredObjects[cid];}, this)).concat(this.registeredObjects);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Binds or unbinds the \"all\"-listener for one or more objects.\r\n\t * \r\n\t * @param  {String}   which \tEither \"on\" or \"off\"\r\n\t * @param  {Object[]} objects \tArray of the objects on which the \"all\"-listener should be bound / unbound to\r\n\t * @param  {Function} [fn] \t\tThe function that should be bound / unbound. Optional in case of \"off\"\r\n\t * @param  {Object}   [ctx] \tThe context the function should be called in\r\n\t * @return {undefined}\r\n\t */\r\n\tfunction onoff(which, objects, fn, ctx) {\r\n\t\tfor (var i = 0, l = objects.length, obj; i < l; i++) {\r\n\t\t\tobj = objects[i];\r\n\t\t\tif (!obj) continue;\r\n\t\t\tif (which === \"on\") {\r\n\t\t\t\tif (!ctx.objectRegistry.register(obj)) {\r\n\t\t\t\t\t// register returned false, so obj was already registered\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!ctx.objectRegistry.unregister(obj)) {\r\n\t\t\t\t\t// unregister returned false, so obj wasn't registered\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (_.isFunction(obj[which])) {\r\n\t\t\t\tobj[which](\"all\", fn, ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the undo/redo-function for a specific action.\r\n\t * \r\n\t * @param  {String} which \tEither \"undo\" or \"redo\"\r\n\t * @param  {Object} action \tThe Action's attributes\r\n\t * @return {undefined}\r\n\t */\r\n\tfunction actionUndoRedo (which, action) {\r\n\t\tvar type = action.type, undoTypes = action.undoTypes, fn = !undoTypes[type] || undoTypes[type][which];\r\n\t\tif (_.isFunction(fn)) {\r\n\t\t\tfn(action.object, action.before, action.after, action.options);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * The main undo/redo function.\r\n\t *\r\n\t * @param  {String} \t\twhich \t    Either \"undo\" or \"redo\"\r\n\t * @param  {UndoManager} \tmanager\t    The UndoManager-instance on which an \"undo\"/\"redo\"-Event is triggered afterwards\r\n\t * @param  {UndoStack} \t\tstack \t    The UndoStack on which we perform\r\n\t * @param  {Boolean} \t\tmagic \t    If true, undoes / redoes all actions with the same magicFusionIndex\r\n\t * @param  {Boolean} \t\teverything  If true, undoes / redoes every action that had been tracked\r\n\t * @return {undefined}\r\n\t */\r\n\tfunction managerUndoRedo (which, manager, stack, magic, everything) {\r\n\t\tif (stack.isCurrentlyUndoRedoing || \r\n\t\t\t(which === \"undo\" && stack.pointer === -1) ||\r\n\t\t\t(which === \"redo\" && stack.pointer === stack.length - 1)) {\r\n\t\t\t// We're either currently in an undo- / redo-process or \r\n\t\t\t// we reached the end of the stack\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tstack.isCurrentlyUndoRedoing = true;\r\n\t\tvar action, actions, isUndo = which === \"undo\";\r\n\t\tif (everything) {\r\n\t\t\t// Undo / Redo all steps until you reach the stack's beginning / end\r\n\t\t\tactions = isUndo && stack.pointer === stack.length - 1 || // If at the stack's end calling undo\r\n\t\t\t\t\t  !isUndo && stack.pointer === -1 ? // or at the stack's beginning calling redo\r\n\t\t\t\t\t  _.clone(stack.models) : // => Take all the models. Otherwise:\r\n\t\t\t\t\t  core_slice.apply(stack.models, isUndo ? [0, stack.pointer] : [stack.pointer, stack.length - 1]);\r\n\t\t} else {\r\n\t\t\t// Undo / Redo only one step\r\n\t\t\taction = stack.at(isUndo ? stack.pointer : stack.pointer + 1);\r\n\t\t\tactions = magic ? stack.where({\"magicFusionIndex\": action.get(\"magicFusionIndex\")}) : [action];\r\n\t\t}\r\n\t\t\r\n\t\tstack.pointer += (isUndo ? -1 : 1) * actions.length;\r\n\t\twhile (action = isUndo ? actions.pop() : actions.shift()) {\r\n\t\t\t// Here we're calling the Action's undo / redo method\r\n\t\t\taction[which]();\r\n\t\t}\r\n\t\tstack.isCurrentlyUndoRedoing = false;\r\n\r\n\t\tmanager.trigger(which, manager);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether an UndoAction should be created or not. Therefore it checks\r\n\t * whether a \"condition\" property is set in the undoTypes-object of the specific\r\n\t * event type. If not, it returns true. If it's set and a boolean, it returns it.\r\n\t * If it's a function, it returns its result, converting it into a boolean. \r\n\t * Otherwise it returns true.\r\n\t * \r\n\t * @param  {Object} \tundoTypesType \tThe object within the UndoTypes that holds the function for this event type (i.e. \"change\")\r\n\t * @param  {Arguments} \targs       \t\tThe arguments the \"condition\" function is called with\r\n\t * @return {Boolean} \tTrue, if an UndoAction should be created\r\n\t */\r\n\tfunction validateUndoActionCreation (undoTypesType, args) {\r\n\t\tvar condition = undoTypesType.condition, type = typeof condition;\r\n\t\treturn type === \"function\" ? !!apply(condition, undoTypesType, args) :\r\n\t\t\ttype === \"boolean\" ? condition : true;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds an Undo-Action to the stack.\r\n\t * \r\n\t * @param {UndoStack} \t\tstack \t\tThe undostack the action should be added to.\r\n\t * @param {String} \t\t\ttype \t\tThe event type (i.e. \"change\")\r\n\t * @param {Arguments} \t\targs \t\tThe arguments passed to the undoTypes' \"on\"-handler\r\n\t * @param {OwnedUndoTypes} \tundoTypes \tThe undoTypes-object which has the \"on\"-handler\r\n\t * @return {undefined}\r\n\t */\r\n\tfunction addToStack(stack, type, args, undoTypes) {\r\n\t\tif (stack.track && !stack.isCurrentlyUndoRedoing && type in undoTypes &&\r\n\t\t\tvalidateUndoActionCreation(undoTypes[type], args)) {\r\n\t\t\t// An UndoAction should be created\r\n\t\t\tvar res = apply(undoTypes[type][\"on\"], undoTypes[type], args), diff;\r\n\t\t\tif (hasKeys(res, \"object\", \"before\", \"after\")) {\r\n\t\t\t\tres.type = type;\r\n\t\t\t\tres.magicFusionIndex = getMagicFusionIndex();\r\n\t\t\t\tres.undoTypes = undoTypes;\r\n\t\t\t\tif (stack.pointer < stack.length - 1) {\r\n\t\t\t\t\t// New Actions must always be added to the end of the stack.\r\n\t\t\t\t\t// If the pointer is not pointed to the last action in the\r\n\t\t\t\t\t// stack, presumably because actions were undone before, then\r\n\t\t\t\t\t// all following actions must be discarded\r\n\t\t\t\t\tvar diff = stack.length - stack.pointer - 1;\r\n\t\t\t\t\twhile (diff--) {\r\n\t\t\t\t\t\tstack.pop();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstack.pointer = stack.length;\r\n\t\t\t\tstack.add(res);\r\n\t\t\t\tif (stack.length > stack.maximumStackLength) {\r\n\t\t\t\t\tstack.shift();\r\n\t\t\t\t\tstack.pointer--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Predefined UndoTypes object with default handlers for the most common events.\r\n\t * @type {Object}\r\n\t */\r\n\tvar UndoTypes = {\r\n\t\t\"add\": {\r\n\t\t\t\"undo\": function (collection, ignore, model, options) {\r\n\t\t\t\t// Undo add = remove\r\n\t\t\t\tcollection.remove(model, options);\r\n\t\t\t},\r\n\t\t\t\"redo\": function (collection, ignore, model, options) {\r\n\t\t\t\t// Redo add = add\r\n\t\t\t\tif (options.index) {\r\n\t\t\t\t\toptions.at = options.index;\r\n\t\t\t\t}\r\n\t\t\t\tcollection.add(model, options);\r\n\t\t\t},\r\n\t\t\t\"on\": function (model, collection, options) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tobject: collection,\r\n\t\t\t\t\tbefore: undefined,\r\n\t\t\t\t\tafter: model,\r\n\t\t\t\t\toptions: _.clone(options)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\t\"remove\": {\r\n\t\t\t\"undo\": function (collection, model, ignore, options) {\r\n\t\t\t\tif (\"index\" in options) {\r\n\t\t\t\t\toptions.at = options.index;\r\n\t\t\t\t}\r\n\t\t\t\tcollection.add(model, options);\r\n\t\t\t},\r\n\t\t\t\"redo\": function (collection, model, ignore, options) {\r\n\t\t\t\tcollection.remove(model, options);\r\n\t\t\t},\r\n\t\t\t\"on\": function (model, collection, options) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tobject: collection,\r\n\t\t\t\t\tbefore: model,\r\n\t\t\t\t\tafter: undefined,\r\n\t\t\t\t\toptions: _.clone(options)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\t\"change\": {\r\n\t\t\t\"undo\": function (model, before, after, options) {\r\n\t\t\t\tif (_.isEmpty(before)) {\r\n\t\t\t\t\t_.each(_.keys(after), model.unset, model);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmodel.set(before);\r\n\t\t\t\t\tif (options && options.unsetData && options.unsetData.before && options.unsetData.before.length) {\r\n\t\t\t\t\t\t_.each(options.unsetData.before, model.unset, model);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"redo\": function (model, before, after, options) {\r\n\t\t\t\tif (_.isEmpty(after)) {\r\n\t\t\t\t\t_.each(_.keys(before), model.unset, model);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmodel.set(after);\r\n\t\t\t\t\tif (options && options.unsetData && options.unsetData.after && options.unsetData.after.length) {\r\n\t\t\t\t\t\t_.each(options.unsetData.after, model.unset, model);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"on\": function (model, options) {\r\n\t\t\t\tvar\r\n\t\t\t\tafterAttributes = model.changedAttributes(),\r\n\t\t\t\tkeysAfter = _.keys(afterAttributes),\r\n\t\t\t\tpreviousAttributes = _.pick(model.previousAttributes(), keysAfter),\r\n\t\t\t\tkeysPrevious = _.keys(previousAttributes),\r\n\t\t\t\tunsetData = (options || (options = {})).unsetData = {\r\n\t\t\t\t\tafter: [],\r\n\t\t\t\t\tbefore: []\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (keysAfter.length != keysPrevious.length) {\r\n\t\t\t\t\t// There are new attributes or old attributes have been unset\r\n\t\t\t\t\tif (keysAfter.length > keysPrevious.length) {\r\n\t\t\t\t\t\t// New attributes have been added\r\n\t\t\t\t\t\t_.each(keysAfter, function (val) {\r\n\t\t\t\t\t\t\tif (!(val in previousAttributes)) {\r\n\t\t\t\t\t\t\t\tunsetData.before.push(val);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Old attributes have been unset\r\n\t\t\t\t\t\t_.each(keysPrevious, function (val) {\r\n\t\t\t\t\t\t\tif (!(val in afterAttributes)) {\r\n\t\t\t\t\t\t\t\tunsetData.after.push(val);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tobject: model,\r\n\t\t\t\t\tbefore: previousAttributes,\r\n\t\t\t\t\tafter: afterAttributes,\r\n\t\t\t\t\toptions: _.clone(options)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\t\"reset\": {\r\n\t\t\t\"undo\": function (collection, before, after) {\r\n\t\t\t\tcollection.reset(before);\r\n\t\t\t},\r\n\t\t\t\"redo\": function (collection, before, after) {\r\n\t\t\t\tcollection.reset(after);\r\n\t\t\t},\r\n\t\t\t\"on\": function (collection, options) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tobject: collection,\r\n\t\t\t\t\tbefore: options.previousModels,\r\n\t\t\t\t\tafter: _.clone(collection.models)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Every UndoManager instance has an own undoTypes object\r\n\t * which is an instance of OwnedUndoTypes. OwnedUndoTypes' \r\n\t * prototype is the global UndoTypes object. Changes to the \r\n\t * global UndoTypes object take effect on every instance of\r\n\t * UndoManager as the object is its prototype. And yet every \r\n\t * local UndoTypes object can be changed individually.\r\n\t *\r\n\t * @constructor\r\n\t */\r\n\tfunction OwnedUndoTypes () {}\r\n\tOwnedUndoTypes.prototype = UndoTypes;\r\n\r\n\t/**\r\n\t * Adds, changes or removes an undo-type from an UndoTypes-object.\r\n\t * You can call it this way:\r\n\t * manipulateUndoType (1, \"reset\", {\"on\": function () {}}, undoTypes)\r\n\t * or this way to perform bulk actions:\r\n\t * manipulateUndoType (1, {\"reset\": {\"on\": function () {}}}, undoTypes)\r\n\t * In case of removing undo-types you can pass an Array for performing\r\n\t * bulk actions:\r\n\t * manipulateUndoType(2, [\"reset\", \"change\"], undoTypes)\r\n\t * \r\n\t * @param  {Number} \t\t\t\t  manipType \t\tIndicates the kind of action to execute: 0 for add, 1 for change, 2 for remove\r\n\t * @param  {String|Object|Array} \t  undoType \t\t\tThe type of undoType that should be added/changed/removed. Can be an object / array to perform bulk actions\r\n\t * @param  {Object} \t\t\t\t  [fns] \t\t\tObject with the functions to add / change. Is optional in case you passed an object as undoType that contains these functions\r\n\t * @param  {OwnedUndoTypes|UndoTypes} undoTypesInstance The undoTypes object to act on\r\n\t * @return {undefined}\r\n\t */\r\n\tfunction manipulateUndoType (manipType, undoType, fns, undoTypesInstance) {\r\n\t\t// manipType, passed by the calling function\r\n\t\t// 0: add\r\n\t\t// 1: change\r\n\t\t// 2: remove\r\n\t\tif (typeof undoType === \"object\") {\r\n\t\t\t// bulk action. Iterate over this data.\r\n\t\t\treturn _.each(undoType, function (val, key) {\r\n\t\t\t\t\tif (manipType === 2) { // remove\r\n\t\t\t\t\t\t// undoType is an array\r\n\t\t\t\t\t\tmanipulateUndoType (manipType, val, fns, undoTypesInstance);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// undoType is an object\r\n\t\t\t\t\t\tmanipulateUndoType (manipType, key, val, fns);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t}\r\n\r\n\t\tswitch (manipType) {\r\n\t\t\tcase 0: // add\r\n\t\t\t\tif (hasKeys(fns, \"undo\", \"redo\", \"on\") && _.all(_.pick(fns, \"undo\", \"redo\", \"on\"), _.isFunction)) {\r\n\t\t\t\t\tundoTypesInstance[undoType] = fns;\r\n\t\t\t\t} \r\n\t\t\tbreak;\r\n\t\t\tcase 1: // change\r\n\t\t\t\tif (undoTypesInstance[undoType] && _.isObject(fns)) {\r\n\t\t\t\t\t// undoTypeInstance[undoType] may be a prototype's property\r\n\t\t\t\t\t// So, if we did this _.extend(undoTypeInstance[undoType], fns)\r\n\t\t\t\t\t// we would extend the object on the prototype which means\r\n\t\t\t\t\t// that this change would have a global effect\r\n\t\t\t\t\t// Instead we just want to manipulate this instance. That's why\r\n\t\t\t\t\t// we're doing this:\r\n\t\t\t\t\tundoTypesInstance[undoType] = _.extend({}, undoTypesInstance[undoType], fns);\r\n\t\t\t\t} \r\n\t\t\tbreak;\r\n\t\t\tcase 2: // remove\r\n\t\t\t\tdelete undoTypesInstance[undoType]; \r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Instantiating \"Action\" creates the UndoActions that \r\n\t * are collected in an UndoStack. It holds all relevant \r\n\t * data to undo / redo an action and has an undo / redo \r\n\t * method.\r\n\t */\r\n\tvar Action = Model.extend({\r\n\t\tdefaults: {\r\n\t\t\ttype: null, // \"add\", \"change\", \"reset\", etc.\r\n\t\t\tobject: null, // The object on which the action occurred\r\n\t\t\tbefore: null, // The previous values which were changed with this action\r\n\t\t\tafter: null, // The values after this action\r\n\t\t\tmagicFusionIndex: null // The magicFusionIndex helps to combine \r\n\t\t\t// all actions that occurred \"at the same time\" to undo/redo them altogether\r\n\t\t},\r\n\t\t/**\r\n\t\t * Undoes this action.\r\n\t\t * @param  {OwnedUndoTypes|UndoTypes} undoTypes The undoTypes object which contains the \"undo\"-handler that should be used\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tundo: function (undoTypes) {\r\n\t\t\tactionUndoRedo(\"undo\", this.attributes);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Redoes this action.\r\n\t\t * @param  {OwnedUndoTypes|UndoTypes} undoTypes The undoTypes object which contains the \"redo\"-handler that should be used\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tredo: function (undoTypes) {\r\n\t\t\tactionUndoRedo(\"redo\", this.attributes);\r\n\t\t}\r\n\t}),\r\n\t/**\r\n\t * An UndoStack is a collection of UndoActions in \r\n\t * chronological order.\r\n\t */\r\n\tUndoStack = Collection.extend({\r\n\t\tmodel: Action,\r\n\t\tpointer: -1, // The pointer indicates the index where we are located within the stack. We start at -1\r\n\t\ttrack: false,\r\n\t\tisCurrentlyUndoRedoing: false,\r\n\t\tmaximumStackLength: Infinity,\r\n\t\tsetMaxLength: function (val) {\r\n\t\t\tthis.maximumStackLength = val;\r\n\t\t}\r\n\t}),\r\n\t/**\r\n\t * An instance of UndoManager can keep track of \r\n\t * changes to objects and helps to undo them.\r\n\t */\r\n\tUndoManager = Model.extend({\r\n\t\tdefaults: {\r\n\t\t\tmaximumStackLength: Infinity,\r\n\t\t\ttrack: false\r\n\t\t},\r\n\t\t/**\r\n\t\t * The constructor function.\r\n\t\t * @param  {attr} \t\t[attr] Object with parameters. The available parameters are:\r\n\t\t *                         \t   - maximumStackLength {number} \tSet the undo-stack's maximum size\r\n\t\t *                             - track \t\t\t\t{boolean}\tStart tracking changes right away\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tinitialize: function (attr) {\r\n\t\t\tthis.stack = new UndoStack;\r\n\t\t\tthis.objectRegistry = new ObjectRegistry();\r\n\t\t\tthis.undoTypes = new OwnedUndoTypes();\r\n\r\n\t\t\t// sync the maximumStackLength attribute with our stack\r\n\t\t\tthis.stack.setMaxLength(this.get(\"maximumStackLength\"));\r\n\t\t\tthis.on(\"change:maximumStackLength\", function (model, value) {\r\n\t\t\t\tthis.stack.setMaxLength(value);\r\n\t\t\t}, this);\r\n\r\n\t\t\t// Start tracking, if attr.track == true\r\n\t\t\tif (attr && attr.track) {\r\n\t\t\t\tthis.startTracking();\r\n\t\t\t}\r\n\r\n\t\t\t// Register objects passed in the \"register\" attribute\r\n\t\t\tif (attr && attr.register) {\r\n\t\t\t\tif (_.isArray(attr.register) || _.isArguments(attr.register)) {\r\n\t\t\t\t\tapply(this.register, this, attr.register);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.register(attr.register);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t * Starts tracking. Changes of registered objects won't be processed until you've called this function\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tstartTracking: function () {\r\n\t\t\tthis.set(\"track\", true);\r\n\t\t\tthis.stack.track = true;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Stops tracking. Afterwards changes of registered objects won't be processed.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tstopTracking: function () {\r\n\t\t\tthis.set(\"track\", false);\r\n\t\t\tthis.stack.track = false;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Return the state of the tracking\r\n\t\t * @return {boolean}\r\n\t\t */\r\n\t\tisTracking: function () {\r\n\t\t\treturn this.get(\"track\");\r\n\t\t},\r\n\t\t/**\r\n\t\t * This is the \"all\"-handler which is bound to registered \r\n\t\t * objects. It creates an UndoAction from the event and adds \r\n\t\t * it to the stack.\r\n\t\t * \r\n\t\t * @param  {String} \ttype \tThe event type\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\t_addToStack: function (type) {\r\n\t\t\taddToStack(this.stack, type, slice(arguments, 1), this.undoTypes);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Registers one or more objects to track their changes.\r\n\t\t * @param {...Object} \tobj \tThe object or objects of which changes should be tracked\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tregister: function () {\r\n\t\t\tonoff(\"on\", arguments, this._addToStack, this);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Unregisters one or more objects.\r\n\t\t * @param {...Object} \tobj \tThe object or objects of which changes shouldn't be tracked any longer\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tunregister: function () {\r\n\t\t\tonoff(\"off\", arguments, this._addToStack, this);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Unregisters all previously registered objects.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tunregisterAll: function () {\r\n\t\t\tapply(this.unregister, this, this.objectRegistry.get());\r\n\t\t},\r\n\t\t/**\r\n\t\t * Undoes the last action or the last set of actions in case 'magic' is true.\r\n\t\t * @param {Boolean} \t[magic] \tIf true, all actions that happened basically at the same time are undone together\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tundo: function (magic) {\r\n\t\t\tmanagerUndoRedo(\"undo\", this, this.stack, magic);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Undoes all actions ever tracked by the undo manager\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tundoAll: function () {\r\n\t\t\tmanagerUndoRedo(\"undo\", this, this.stack, false, true);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Redoes a previously undone action or a set of actions.\r\n\t\t * @param {Boolean} \t[magic] \tIf true, all actions that happened basically at the same time are redone together\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tredo: function (magic) {\r\n\t\t\tmanagerUndoRedo(\"redo\", this, this.stack, magic);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Redoes all actions ever tracked by the undo manager\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tredoAll: function () {\r\n\t\t\tmanagerUndoRedo(\"redo\", this, this.stack, false, true);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Checks if there's an action in the stack that can be undone / redone\r\n\t\t * @param  {String} \ttype \tEither \"undo\" or \"redo\"\r\n\t\t * @return {Boolean} True if there is a set of actions which can be undone / redone\r\n\t\t */\r\n\t\tisAvailable: function (type) {\r\n\t\t\tvar s = this.stack, l = s.length;\r\n\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase \"undo\": return l > 0 && s.pointer > -1;\r\n\t\t\t\tcase \"redo\": return l > 0 && s.pointer < l - 1;\r\n\t\t\t\tdefault: return false;\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t * Sets the stack-reference to the stack of another undoManager.\r\n\t\t * @param  {UndoManager} \tundoManager \tThe undoManager whose stack-reference is set to this stack\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tmerge: function (undoManager) {\r\n\t\t\t// This sets the stack-reference to the stack of another \r\n\t\t\t// undoManager so that the stack of this other undoManager \r\n\t\t\t// is used by two different managers.\r\n\t\t\t// This enables to set up a main-undoManager and besides it\r\n\t\t\t// several others for special, exceptional cases (by using\r\n\t\t\t// instance-based custom UndoTypes). Models / collections \r\n\t\t\t// which need this special treatment are only registered at \r\n\t\t\t// those special undoManagers. Those special ones are then \r\n\t\t\t// merged into the main-undoManager to write on its stack. \r\n\t\t\t// That way it's easier to manage exceptional cases.\r\n\t\t\tvar args = _.isArray(undoManager) ? undoManager : slice(arguments), manager;\r\n\t\t\twhile (manager = args.pop()) {\r\n\t\t\t\tif (manager instanceof UndoManager &&\r\n\t\t\t\t\tmanager.stack instanceof UndoStack) {\r\n\t\t\t\t\t// set the stack reference to our stack\r\n\t\t\t\t\tmanager.stack = this.stack;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t/**\r\n\t\t * Add an UndoType to this specific UndoManager-instance.\r\n\t\t * @param {String} type The event this UndoType is made for\r\n\t\t * @param {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. Must have the properties \"undo\", \"redo\" and \"on\". Can have the property \"condition\".\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\taddUndoType: function (type, fns) {\r\n\t\t\tmanipulateUndoType(0, type, fns, this.undoTypes);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Overwrite properties of an existing UndoType for this specific UndoManager-instance.\r\n\t\t * @param  {String} type The event the UndoType is made for\r\n\t\t * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. It extends the existing object.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tchangeUndoType: function (type, fns) {\r\n\t\t\tmanipulateUndoType(1, type, fns, this.undoTypes);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Remove one or more UndoTypes of this specific UndoManager-instance to fall back to the global UndoTypes.\r\n\t\t * @param  {String|Array} type The event the UndoType that should be removed is made for. You can also pass an array of events.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tremoveUndoType: function (type) {\r\n\t\t\tmanipulateUndoType(2, type, undefined, this.undoTypes);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes all actions from the stack.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tclear: function() {\r\n\t\t\tthis.stack.reset();\r\n\t\t\tthis.stack.pointer = -1;\r\n\t\t}\r\n\t});\r\n\r\n\t_.extend(UndoManager, {\r\n\t\t/**\r\n\t\t * Change the UndoManager's default attributes\r\n\t\t * @param  {Object} defaultAttributes An object with the new default values.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\tdefaults: function (defaultAttributes) {\r\n\t\t\t_.extend(UndoManager.prototype.defaults, defaultAttributes);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Add an UndoType to the global UndoTypes-object.\r\n\t\t * @param  {String} type The event this UndoType is made for\r\n\t\t * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. Must have the properties \"undo\", \"redo\" and \"on\". Can have the property \"condition\".\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\t\"addUndoType\": function (type, fns) {\r\n\t\t\tmanipulateUndoType(0, type, fns, UndoTypes);\r\n\t\t},\r\n\t\t/**\r\n\t\t * Overwrite properties of an existing UndoType in the global UndoTypes-object.\r\n\t\t * @param  {String} type The event the UndoType is made for\r\n\t\t * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. It extends the existing object.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\t\"changeUndoType\": function (type, fns) {\r\n\t\t\tmanipulateUndoType(1, type, fns, UndoTypes)\r\n\t\t},\r\n\t\t/**\r\n\t\t * Remove one or more UndoTypes of this specific UndoManager-instance to fall back to the global UndoTypes.\r\n\t\t * @param  {String|Array} type The event the UndoType that should be removed is made for. You can also pass an array of events.\r\n\t\t * @return {undefined}\r\n\t\t */\r\n\t\t\"removeUndoType\": function (type) {\r\n\t\t\tmanipulateUndoType(2, type, undefined, UndoTypes);\r\n\t\t}\r\n\t})\r\n\r\n\treturn Backbone.UndoManager = UndoManager;\r\n\r\n});\r\n"]}